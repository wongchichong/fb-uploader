import { createStyleState as s, applyStyle as p, mergeStyleStates as m } from "./styler.mjs";
import { getColor as f } from "./registry.mjs";
import { ChalkeeBase as g } from "./ChalkeeBase.mjs";
const d = {};
function h(n, t) {
  return d[n] || (d[n] = t()), d[n];
}
const w = h("createColor", () => ({
  value: function(t, e) {
    const o = this._state || s();
    if (!!this._isInBgMode) {
      const r = `bg${t.charAt(0).toUpperCase()}${t.slice(1)}`, a = f(r);
      if (a) {
        const l = {
          ...o,
          backgroundColors: [a],
          isOpen: !0,
          autoSpacing: o.autoSpacing || !1
        };
        if (e !== void 0) {
          const c = new this.constructor(l, ""), S = p(e, l);
          return c._accumulatedText = this._accumulatedText + S, c._isInBgMode = !0, c;
        } else {
          const c = new this.constructor(l, "");
          return c._accumulatedText = this._accumulatedText, c._isInBgMode = !0, c;
        }
      }
    }
    const u = m(o, {
      ...s(),
      colors: [f(t)],
      isOpen: !0,
      autoSpacing: o.autoSpacing || !1
    });
    if (e !== void 0) {
      const r = new this.constructor(u, ""), a = p(e, u);
      return r._accumulatedText = this._accumulatedText + a, r;
    } else {
      const r = new this.constructor(u, "");
      return r._accumulatedText = this._accumulatedText, r;
    }
  },
  writable: !0,
  enumerable: !1,
  configurable: !0
}));
Object.defineProperty(g.prototype, "createColor", w);
const _ = h("createModifier", () => ({
  value: function(t) {
    const e = this._state || s(), o = m(e, {
      ...s(),
      modifiers: [...e.modifiers || [], t],
      isOpen: !0,
      autoSpacing: e.autoSpacing || !1
    }), i = new this.constructor(o, "");
    return i._accumulatedText = this._accumulatedText, i;
  },
  writable: !0,
  enumerable: !1,
  configurable: !0
}));
Object.defineProperty(g.prototype, "createModifier", _);
//# sourceMappingURL=callable-helpers.mjs.map

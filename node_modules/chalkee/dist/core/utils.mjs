import { getColor as h, parseHex as d, rgbToAnsi256 as b } from "./registry.mjs";
import { createStyleState as n, mergeStyleStates as l } from "./styler.mjs";
import { ChalkeeBase as m } from "./ChalkeeBase.mjs";
function w(a) {
  Object.defineProperty(a.prototype, "createBgColor", {
    value: function(r) {
      const t = this._state || n(), e = h(r);
      if (!e)
        return this;
      const c = l(t, {
        ...n(),
        backgroundColors: [e],
        isOpen: !0,
        autoSpacing: t.autoSpacing || !1
      }), o = new this.constructor(c, "");
      return o._accumulatedText = this._accumulatedText, o;
    },
    writable: !0,
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a.prototype, "createBgReplace", {
    value: function(r) {
      const t = this._state || n(), e = h(r);
      if (!e)
        return this;
      const c = {
        ...n(),
        // Start with a clean state
        backgroundColors: [e],
        // Set only the new background color
        isOpen: !0,
        autoSpacing: t.autoSpacing || !1,
        previousStyles: t
        // Use the current state as the previous styles
      }, o = new this.constructor(c, "");
      return o._accumulatedText = this._accumulatedText || "", o._isInBgMode = !0, S(o), o;
    },
    writable: !0,
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a.prototype, "createReset", {
    value: function() {
      const r = this._state || n(), t = {
        ...n(),
        colors: [],
        modifiers: [],
        backgroundColors: [],
        isOpen: !1,
        autoSpacing: r.autoSpacing || !1
      }, e = new this.constructor(t, "");
      return e._accumulatedText = this._accumulatedText, e;
    },
    writable: !0,
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a.prototype, "createAutoSpacing", {
    value: function() {
      const r = this._state || n(), t = l(r, {
        ...n(),
        isOpen: !0,
        autoSpacing: !0
      }), e = new this.constructor(t, "");
      return e._accumulatedText = this._accumulatedText, this._isInBgMode && (e._isInBgMode = !0), Object.defineProperty(e, "bg", {
        get: function() {
          const c = e.createBgMode();
          return S(c), c;
        },
        enumerable: !0,
        configurable: !0
      }), e;
    },
    writable: !0,
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a.prototype, "createBgMode", {
    value: function() {
      const r = this._state || n(), t = l(r, {
        ...n(),
        isOpen: !0,
        autoSpacing: r.autoSpacing || !1
      }), e = new this.constructor(t, "");
      return e._accumulatedText = this._accumulatedText || "", e._isInBgMode = !0, e;
    },
    writable: !0,
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a.prototype, "createHexColor", {
    value: function(r) {
      const t = this._state || n(), e = d(r);
      if (!e)
        return this;
      const [c, o, s] = e, i = b(c, o, s), p = l(t, {
        ...n(),
        isOpen: !0,
        autoSpacing: t.autoSpacing || !1,
        hexColorCode: `\x1B[38;5;${i}m`
      }), g = new this.constructor(p, "");
      return g._accumulatedText = this._accumulatedText, g;
    },
    writable: !0,
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a.prototype, "createRgbColor", {
    value: function(r, t, e) {
      const c = this._state || n(), o = b(r, t, e), s = l(c, {
        ...n(),
        isOpen: !0,
        autoSpacing: c.autoSpacing || !1,
        rgbColorCode: `\x1B[38;5;${o}m`
      }), i = new this.constructor(s, "");
      return i._accumulatedText = this._accumulatedText, i;
    },
    writable: !0,
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a.prototype, "createBgHexColor", {
    value: function(r) {
      const t = this._state || n(), e = d(r);
      if (!e)
        return this;
      const [c, o, s] = e, i = b(c, o, s), p = l(t, {
        ...n(),
        isOpen: !0,
        autoSpacing: t.autoSpacing || !1,
        bgHexColorCode: `\x1B[48;5;${i}m`
      }), g = new this.constructor(p, "");
      return g._accumulatedText = this._accumulatedText, g;
    },
    writable: !0,
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(a.prototype, "createBgRgbColor", {
    value: function(r, t, e) {
      const c = this._state || n(), o = b(r, t, e), s = l(c, {
        ...n(),
        isOpen: !0,
        autoSpacing: c.autoSpacing || !1,
        bgRgbColorCode: `\x1B[48;5;${o}m`
      }), i = new this.constructor(s, "");
      return i._accumulatedText = this._accumulatedText, i;
    },
    writable: !0,
    enumerable: !1,
    configurable: !0
  });
}
const f = {};
function B(a, u) {
  const r = `${a}_${u}`;
  if (f[r])
    return f[r];
  const t = {
    get() {
      return this.createBgReplace(u);
    },
    enumerable: !0,
    configurable: !0
  };
  return f[r] = t, t;
}
function S(a) {
  const u = {
    red: "bgRed",
    green: "bgGreen",
    blue: "bgBlue",
    yellow: "bgYellow",
    magenta: "bgMagenta",
    cyan: "bgCyan",
    white: "bgWhite",
    black: "bgBlack",
    gray: "bgBlackBright",
    grey: "bgBlackBright",
    redBright: "bgRedBright",
    greenBright: "bgGreenBright",
    blueBright: "bgBlueBright",
    yellowBright: "bgYellowBright",
    magentaBright: "bgMagentaBright",
    cyanBright: "bgCyanBright",
    whiteBright: "bgWhiteBright",
    blackBright: "bgBlackBright"
  };
  for (const [r, t] of Object.entries(u)) {
    const e = B(r, t);
    Object.defineProperty(a, r, e);
  }
}
w(m);
export {
  S as attachSpecialBgMethods
};
//# sourceMappingURL=utils.mjs.map

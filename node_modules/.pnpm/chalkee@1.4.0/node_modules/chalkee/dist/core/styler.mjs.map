{"version":3,"file":"styler.mjs","sources":["../../src/core/styler.ts"],"sourcesContent":["/**\n * Styler engine for applying ANSI escape codes to text\n */\n\nimport { StyleChainState } from '../types'\nimport { parseHex, rgbToAnsi256 } from './registry'\nimport { ChalkeeBase } from './ChalkeeBase'\n\n// Modifier lookup function to be set by modifiers module to avoid circular dependencies\nlet modifierLookup: (name: string) => number | undefined\n\n/**\n * Set the modifier lookup function\n * @param fn The lookup function\n */\nexport function setModifierLookup(fn: (name: string) => number | undefined): void {\n    modifierLookup = fn\n}\n\n// Cache for ANSI code generation to avoid redundant string concatenation\nconst ansiCodeCache = new Map<string, string>()\n\n/**\n * Convert a style chain state to ANSI escape codes with caching\n * @param state The style chain state\n * @returns The ANSI escape code string\n */\nexport function styleStateToAnsi(state: StyleChainState): string {\n    // Check for hex/rgb color codes first (they override normal colors)\n    if ((state as any).hexColorCode) {\n        return (state as any).hexColorCode\n    }\n    if ((state as any).rgbColorCode) {\n        return (state as any).rgbColorCode\n    }\n    if ((state as any).bgHexColorCode) {\n        return (state as any).bgHexColorCode\n    }\n    if ((state as any).bgRgbColorCode) {\n        return (state as any).bgRgbColorCode\n    }\n\n    const codes: number[] = []\n\n    // Add modifier codes\n    for (const modifier of state.modifiers) {\n        const code = modifierLookup ? modifierLookup(modifier) : undefined\n        if (code !== undefined) {\n            codes.push(code)\n        }\n    }\n\n    // Add foreground color codes\n    for (const color of state.colors) {\n        codes.push(color.ansiCode)\n    }\n\n    // Add background color codes\n    for (const color of state.backgroundColors) {\n        codes.push(color.ansiCode)\n    }\n\n    // If no codes, return empty string\n    if (codes.length === 0) {\n        return ''\n    }\n\n    // Create cache key from codes\n    const cacheKey = codes.join(';')\n\n    // Check cache first\n    if (ansiCodeCache.has(cacheKey)) {\n        return ansiCodeCache.get(cacheKey)!\n    }\n\n    // Generate and cache the ANSI escape sequence\n    const ansiCode = `\\x1b[${cacheKey}m`\n    ansiCodeCache.set(cacheKey, ansiCode)\n    return ansiCode\n}\n\n/**\n * Create a reset ANSI escape code\n * @returns The reset ANSI escape code\n */\nexport function createReset(): string {\n    return '\\x1b[0m'\n}\n\n/**\n * Create a hex color ANSI escape code\n * @param hex The hex color string\n * @param isBackground Whether this is a background color\n * @returns The ANSI escape code for the hex color\n */\nexport function createHexCode(hex: string, isBackground: boolean = false): string {\n    const [r, g, b] = parseHex(hex)\n    const ansi256 = rgbToAnsi256(r, g, b)\n    const code = isBackground ? 48 : 38\n    return `\\x1b[${code};5;${ansi256}m`\n}\n\n/**\n * Create an RGB color ANSI escape code\n * @param r Red value (0-255)\n * @param g Green value (0-255)\n * @param b Blue value (0-255)\n * @param isBackground Whether this is a background color\n * @returns The ANSI escape code for the RGB color\n */\nexport function createRgbCode(r: number, g: number, b: number, isBackground: boolean = false): string {\n    const ansi256 = rgbToAnsi256(r, g, b)\n    const code = isBackground ? 48 : 38\n    return `\\x1b[${code};5;${ansi256}m`\n}\n\n/**\n * Apply styling to text based on the current state\n * @param text The text to style\n * @param state The current style state\n * @returns The styled text with ANSI escape codes\n */\nexport function applyStyle(text: string, state: StyleChainState): string {\n    // Use ChalkeeBase.noColor to control color output\n    if (ChalkeeBase.noColor) {\n        return text\n    }\n\n    const open = styleStateToAnsi(state)\n    const close = createReset()\n\n    // If auto-spacing is enabled, add a space before the text (except for the first element)\n    // Only add space if previousStyles has actual styles applied\n    if (state.autoSpacing && state.previousStyles && (state.previousStyles.colors.length > 0 || state.previousStyles.modifiers.length > 0 || state.previousStyles.backgroundColors.length > 0)) {\n        // For auto-spacing, the space should not have any styling per user requirement\n        // Spaces should be visually neutral\n        const spaceOpen = '' // No styling on space\n        // Apply full styling to the actual text\n        const textOpen = styleStateToAnsi(state)\n        // The space should be part of the styled text, not a separate element\n        return spaceOpen + ' ' + textOpen + text + close\n    }\n\n    return open + text + close\n}\n\n/**\n * Merge two style states with structural sharing\n * Only creates new arrays when styles actually change\n * @param base The base style state\n * @param overlay The overlay style state\n * @returns The merged style state\n */\nexport function mergeStyleStates(base: StyleChainState, overlay: StyleChainState): StyleChainState {\n    // Optimize: if overlay has no modifiers, reuse base modifiers array\n    let mergedModifiers = base.modifiers\n    if (overlay.modifiers.length > 0) {\n        // Only create a new array if we need to merge\n        const allModifiers = overlay.modifiers.length > 0\n            ? [...base.modifiers, ...overlay.modifiers]\n            : base.modifiers\n        // Use Set to deduplicate, then convert back to array\n        mergedModifiers = allModifiers.length > 0 && new Set(allModifiers).size < allModifiers.length\n            ? [...new Set(allModifiers)]\n            : allModifiers\n    }\n\n    const merged: any = {\n        colors: base.colors.length > 0 || overlay.colors.length > 0\n            ? [...base.colors, ...overlay.colors]\n            : base.colors,\n        modifiers: mergedModifiers,\n        backgroundColors: base.backgroundColors.length > 0 || overlay.backgroundColors.length > 0\n            ? [...base.backgroundColors, ...overlay.backgroundColors]\n            : base.backgroundColors,\n        isOpen: overlay.isOpen,\n        previousStyles: base,\n        autoSpacing: overlay.autoSpacing\n    }\n\n    // Preserve hex/rgb color codes from overlay\n    if ((overlay as any).hexColorCode) {\n        merged.hexColorCode = (overlay as any).hexColorCode\n    }\n    if ((overlay as any).rgbColorCode) {\n        merged.rgbColorCode = (overlay as any).rgbColorCode\n    }\n    if ((overlay as any).bgHexColorCode) {\n        merged.bgHexColorCode = (overlay as any).bgHexColorCode\n    }\n    if ((overlay as any).bgRgbColorCode) {\n        merged.bgRgbColorCode = (overlay as any).bgRgbColorCode\n    }\n\n    return merged as StyleChainState\n}\n/**\n * Create a new style chain state\n * @returns A new style chain state\n */\n\nexport function createStyleState(): StyleChainState {\n    return {\n        colors: [],\n        modifiers: [],\n        backgroundColors: [],\n        isOpen: false,\n        autoSpacing: false\n    }\n}\n"],"names":["modifierLookup","setModifierLookup","fn","ansiCodeCache","styleStateToAnsi","state","codes","modifier","code","color","cacheKey","ansiCode","createReset","applyStyle","text","ChalkeeBase","open","close","mergeStyleStates","base","overlay","mergedModifiers","allModifiers","merged","createStyleState"],"mappings":";AASA,IAAIA;AAMG,SAASC,EAAkBC,GAAgD;AAC9E,EAAAF,IAAiBE;AACrB;AAGA,MAAMC,wBAAoB,IAAA;AAOnB,SAASC,EAAiBC,GAAgC;AAE7D,MAAKA,EAAc;AACf,WAAQA,EAAc;AAE1B,MAAKA,EAAc;AACf,WAAQA,EAAc;AAE1B,MAAKA,EAAc;AACf,WAAQA,EAAc;AAE1B,MAAKA,EAAc;AACf,WAAQA,EAAc;AAG1B,QAAMC,IAAkB,CAAA;AAGxB,aAAWC,KAAYF,EAAM,WAAW;AACpC,UAAMG,IAAOR,IAAiBA,EAAeO,CAAQ,IAAI;AACzD,IAAIC,MAAS,UACTF,EAAM,KAAKE,CAAI;AAAA,EAEvB;AAGA,aAAWC,KAASJ,EAAM;AACtB,IAAAC,EAAM,KAAKG,EAAM,QAAQ;AAI7B,aAAWA,KAASJ,EAAM;AACtB,IAAAC,EAAM,KAAKG,EAAM,QAAQ;AAI7B,MAAIH,EAAM,WAAW;AACjB,WAAO;AAIX,QAAMI,IAAWJ,EAAM,KAAK,GAAG;AAG/B,MAAIH,EAAc,IAAIO,CAAQ;AAC1B,WAAOP,EAAc,IAAIO,CAAQ;AAIrC,QAAMC,IAAW,QAAQD,CAAQ;AACjC,SAAAP,EAAc,IAAIO,GAAUC,CAAQ,GAC7BA;AACX;AAMO,SAASC,IAAsB;AAClC,SAAO;AACX;AAmCO,SAASC,EAAWC,GAAcT,GAAgC;AAErE,MAAIU,EAAY;AACZ,WAAOD;AAGX,QAAME,IAAOZ,EAAiBC,CAAK,GAC7BY,IAAQL,EAAA;AAId,SAAIP,EAAM,eAAeA,EAAM,mBAAmBA,EAAM,eAAe,OAAO,SAAS,KAAKA,EAAM,eAAe,UAAU,SAAS,KAAKA,EAAM,eAAe,iBAAiB,SAAS,KAO7K,MAFUD,EAAiBC,CAAK,IAEHS,IAAOG,IAGxCD,IAAOF,IAAOG;AACzB;AASO,SAASC,EAAiBC,GAAuBC,GAA2C;AAE/F,MAAIC,IAAkBF,EAAK;AAC3B,MAAIC,EAAQ,UAAU,SAAS,GAAG;AAE9B,UAAME,IAAeF,EAAQ,UAAU,SAAS,IAC1C,CAAC,GAAGD,EAAK,WAAW,GAAGC,EAAQ,SAAS,IACxCD,EAAK;AAEX,IAAAE,IAAkBC,EAAa,SAAS,KAAK,IAAI,IAAIA,CAAY,EAAE,OAAOA,EAAa,SACjF,CAAC,GAAG,IAAI,IAAIA,CAAY,CAAC,IACzBA;AAAA,EACV;AAEA,QAAMC,IAAc;AAAA,IAChB,QAAQJ,EAAK,OAAO,SAAS,KAAKC,EAAQ,OAAO,SAAS,IACpD,CAAC,GAAGD,EAAK,QAAQ,GAAGC,EAAQ,MAAM,IAClCD,EAAK;AAAA,IACX,WAAWE;AAAA,IACX,kBAAkBF,EAAK,iBAAiB,SAAS,KAAKC,EAAQ,iBAAiB,SAAS,IAClF,CAAC,GAAGD,EAAK,kBAAkB,GAAGC,EAAQ,gBAAgB,IACtDD,EAAK;AAAA,IACX,QAAQC,EAAQ;AAAA,IAChB,gBAAgBD;AAAA,IAChB,aAAaC,EAAQ;AAAA,EAAA;AAIzB,SAAKA,EAAgB,iBACjBG,EAAO,eAAgBH,EAAgB,eAEtCA,EAAgB,iBACjBG,EAAO,eAAgBH,EAAgB,eAEtCA,EAAgB,mBACjBG,EAAO,iBAAkBH,EAAgB,iBAExCA,EAAgB,mBACjBG,EAAO,iBAAkBH,EAAgB,iBAGtCG;AACX;AAMO,SAASC,IAAoC;AAChD,SAAO;AAAA,IACH,QAAQ,CAAA;AAAA,IACR,WAAW,CAAA;AAAA,IACX,kBAAkB,CAAA;AAAA,IAClB,QAAQ;AAAA,IACR,aAAa;AAAA,EAAA;AAErB;"}
{"version":3,"file":"styler.cjs","sources":["../../src/core/styler.ts"],"sourcesContent":["/**\n * Styler engine for applying ANSI escape codes to text\n */\n\nimport { StyleChainState } from '../types'\nimport { parseHex, rgbToAnsi256 } from './registry'\nimport { ChalkeeBase } from './ChalkeeBase'\n\n// Modifier lookup function to be set by modifiers module to avoid circular dependencies\nlet modifierLookup: (name: string) => number | undefined\n\n/**\n * Set the modifier lookup function\n * @param fn The lookup function\n */\nexport function setModifierLookup(fn: (name: string) => number | undefined): void {\n    modifierLookup = fn\n}\n\n// Cache for ANSI code generation to avoid redundant string concatenation\nconst ansiCodeCache = new Map<string, string>()\n\n/**\n * Convert a style chain state to ANSI escape codes with caching\n * @param state The style chain state\n * @returns The ANSI escape code string\n */\nexport function styleStateToAnsi(state: StyleChainState): string {\n    // Check for hex/rgb color codes first (they override normal colors)\n    if ((state as any).hexColorCode) {\n        return (state as any).hexColorCode\n    }\n    if ((state as any).rgbColorCode) {\n        return (state as any).rgbColorCode\n    }\n    if ((state as any).bgHexColorCode) {\n        return (state as any).bgHexColorCode\n    }\n    if ((state as any).bgRgbColorCode) {\n        return (state as any).bgRgbColorCode\n    }\n\n    const codes: number[] = []\n\n    // Add modifier codes\n    for (const modifier of state.modifiers) {\n        const code = modifierLookup ? modifierLookup(modifier) : undefined\n        if (code !== undefined) {\n            codes.push(code)\n        }\n    }\n\n    // Add foreground color codes\n    for (const color of state.colors) {\n        codes.push(color.ansiCode)\n    }\n\n    // Add background color codes\n    for (const color of state.backgroundColors) {\n        codes.push(color.ansiCode)\n    }\n\n    // If no codes, return empty string\n    if (codes.length === 0) {\n        return ''\n    }\n\n    // Create cache key from codes\n    const cacheKey = codes.join(';')\n\n    // Check cache first\n    if (ansiCodeCache.has(cacheKey)) {\n        return ansiCodeCache.get(cacheKey)!\n    }\n\n    // Generate and cache the ANSI escape sequence\n    const ansiCode = `\\x1b[${cacheKey}m`\n    ansiCodeCache.set(cacheKey, ansiCode)\n    return ansiCode\n}\n\n/**\n * Create a reset ANSI escape code\n * @returns The reset ANSI escape code\n */\nexport function createReset(): string {\n    return '\\x1b[0m'\n}\n\n/**\n * Create a hex color ANSI escape code\n * @param hex The hex color string\n * @param isBackground Whether this is a background color\n * @returns The ANSI escape code for the hex color\n */\nexport function createHexCode(hex: string, isBackground: boolean = false): string {\n    const [r, g, b] = parseHex(hex)\n    const ansi256 = rgbToAnsi256(r, g, b)\n    const code = isBackground ? 48 : 38\n    return `\\x1b[${code};5;${ansi256}m`\n}\n\n/**\n * Create an RGB color ANSI escape code\n * @param r Red value (0-255)\n * @param g Green value (0-255)\n * @param b Blue value (0-255)\n * @param isBackground Whether this is a background color\n * @returns The ANSI escape code for the RGB color\n */\nexport function createRgbCode(r: number, g: number, b: number, isBackground: boolean = false): string {\n    const ansi256 = rgbToAnsi256(r, g, b)\n    const code = isBackground ? 48 : 38\n    return `\\x1b[${code};5;${ansi256}m`\n}\n\n/**\n * Apply styling to text based on the current state\n * @param text The text to style\n * @param state The current style state\n * @returns The styled text with ANSI escape codes\n */\nexport function applyStyle(text: string, state: StyleChainState): string {\n    // Use ChalkeeBase.noColor to control color output\n    if (ChalkeeBase.noColor) {\n        return text\n    }\n\n    const open = styleStateToAnsi(state)\n    const close = createReset()\n\n    // If auto-spacing is enabled, add a space before the text (except for the first element)\n    // Only add space if previousStyles has actual styles applied\n    if (state.autoSpacing && state.previousStyles && (state.previousStyles.colors.length > 0 || state.previousStyles.modifiers.length > 0 || state.previousStyles.backgroundColors.length > 0)) {\n        // For auto-spacing, the space should not have any styling per user requirement\n        // Spaces should be visually neutral\n        const spaceOpen = '' // No styling on space\n        // Apply full styling to the actual text\n        const textOpen = styleStateToAnsi(state)\n        // The space should be part of the styled text, not a separate element\n        return spaceOpen + ' ' + textOpen + text + close\n    }\n\n    return open + text + close\n}\n\n/**\n * Merge two style states with structural sharing\n * Only creates new arrays when styles actually change\n * @param base The base style state\n * @param overlay The overlay style state\n * @returns The merged style state\n */\nexport function mergeStyleStates(base: StyleChainState, overlay: StyleChainState): StyleChainState {\n    // Optimize: if overlay has no modifiers, reuse base modifiers array\n    let mergedModifiers = base.modifiers\n    if (overlay.modifiers.length > 0) {\n        // Only create a new array if we need to merge\n        const allModifiers = overlay.modifiers.length > 0\n            ? [...base.modifiers, ...overlay.modifiers]\n            : base.modifiers\n        // Use Set to deduplicate, then convert back to array\n        mergedModifiers = allModifiers.length > 0 && new Set(allModifiers).size < allModifiers.length\n            ? [...new Set(allModifiers)]\n            : allModifiers\n    }\n\n    const merged: any = {\n        colors: base.colors.length > 0 || overlay.colors.length > 0\n            ? [...base.colors, ...overlay.colors]\n            : base.colors,\n        modifiers: mergedModifiers,\n        backgroundColors: base.backgroundColors.length > 0 || overlay.backgroundColors.length > 0\n            ? [...base.backgroundColors, ...overlay.backgroundColors]\n            : base.backgroundColors,\n        isOpen: overlay.isOpen,\n        previousStyles: base,\n        autoSpacing: overlay.autoSpacing\n    }\n\n    // Preserve hex/rgb color codes from overlay\n    if ((overlay as any).hexColorCode) {\n        merged.hexColorCode = (overlay as any).hexColorCode\n    }\n    if ((overlay as any).rgbColorCode) {\n        merged.rgbColorCode = (overlay as any).rgbColorCode\n    }\n    if ((overlay as any).bgHexColorCode) {\n        merged.bgHexColorCode = (overlay as any).bgHexColorCode\n    }\n    if ((overlay as any).bgRgbColorCode) {\n        merged.bgRgbColorCode = (overlay as any).bgRgbColorCode\n    }\n\n    return merged as StyleChainState\n}\n/**\n * Create a new style chain state\n * @returns A new style chain state\n */\n\nexport function createStyleState(): StyleChainState {\n    return {\n        colors: [],\n        modifiers: [],\n        backgroundColors: [],\n        isOpen: false,\n        autoSpacing: false\n    }\n}\n"],"names":["modifierLookup","setModifierLookup","fn","ansiCodeCache","styleStateToAnsi","state","codes","modifier","code","color","cacheKey","ansiCode","createReset","applyStyle","text","ChalkeeBase","open","close","mergeStyleStates","base","overlay","mergedModifiers","allModifiers","merged","createStyleState"],"mappings":"qHASA,IAAIA,EAMG,SAASC,EAAkBC,EAAgD,CAC9EF,EAAiBE,CACrB,CAGA,MAAMC,MAAoB,IAOnB,SAASC,EAAiBC,EAAgC,CAE7D,GAAKA,EAAc,aACf,OAAQA,EAAc,aAE1B,GAAKA,EAAc,aACf,OAAQA,EAAc,aAE1B,GAAKA,EAAc,eACf,OAAQA,EAAc,eAE1B,GAAKA,EAAc,eACf,OAAQA,EAAc,eAG1B,MAAMC,EAAkB,CAAA,EAGxB,UAAWC,KAAYF,EAAM,UAAW,CACpC,MAAMG,EAAOR,EAAiBA,EAAeO,CAAQ,EAAI,OACrDC,IAAS,QACTF,EAAM,KAAKE,CAAI,CAEvB,CAGA,UAAWC,KAASJ,EAAM,OACtBC,EAAM,KAAKG,EAAM,QAAQ,EAI7B,UAAWA,KAASJ,EAAM,iBACtBC,EAAM,KAAKG,EAAM,QAAQ,EAI7B,GAAIH,EAAM,SAAW,EACjB,MAAO,GAIX,MAAMI,EAAWJ,EAAM,KAAK,GAAG,EAG/B,GAAIH,EAAc,IAAIO,CAAQ,EAC1B,OAAOP,EAAc,IAAIO,CAAQ,EAIrC,MAAMC,EAAW,QAAQD,CAAQ,IACjC,OAAAP,EAAc,IAAIO,EAAUC,CAAQ,EAC7BA,CACX,CAMO,SAASC,GAAsB,CAClC,MAAO,SACX,CAmCO,SAASC,EAAWC,EAAcT,EAAgC,CAErE,GAAIU,EAAAA,YAAY,QACZ,OAAOD,EAGX,MAAME,EAAOZ,EAAiBC,CAAK,EAC7BY,EAAQL,EAAA,EAId,OAAIP,EAAM,aAAeA,EAAM,iBAAmBA,EAAM,eAAe,OAAO,OAAS,GAAKA,EAAM,eAAe,UAAU,OAAS,GAAKA,EAAM,eAAe,iBAAiB,OAAS,GAO7K,IAFUD,EAAiBC,CAAK,EAEHS,EAAOG,EAGxCD,EAAOF,EAAOG,CACzB,CASO,SAASC,EAAiBC,EAAuBC,EAA2C,CAE/F,IAAIC,EAAkBF,EAAK,UAC3B,GAAIC,EAAQ,UAAU,OAAS,EAAG,CAE9B,MAAME,EAAeF,EAAQ,UAAU,OAAS,EAC1C,CAAC,GAAGD,EAAK,UAAW,GAAGC,EAAQ,SAAS,EACxCD,EAAK,UAEXE,EAAkBC,EAAa,OAAS,GAAK,IAAI,IAAIA,CAAY,EAAE,KAAOA,EAAa,OACjF,CAAC,GAAG,IAAI,IAAIA,CAAY,CAAC,EACzBA,CACV,CAEA,MAAMC,EAAc,CAChB,OAAQJ,EAAK,OAAO,OAAS,GAAKC,EAAQ,OAAO,OAAS,EACpD,CAAC,GAAGD,EAAK,OAAQ,GAAGC,EAAQ,MAAM,EAClCD,EAAK,OACX,UAAWE,EACX,iBAAkBF,EAAK,iBAAiB,OAAS,GAAKC,EAAQ,iBAAiB,OAAS,EAClF,CAAC,GAAGD,EAAK,iBAAkB,GAAGC,EAAQ,gBAAgB,EACtDD,EAAK,iBACX,OAAQC,EAAQ,OAChB,eAAgBD,EAChB,YAAaC,EAAQ,WAAA,EAIzB,OAAKA,EAAgB,eACjBG,EAAO,aAAgBH,EAAgB,cAEtCA,EAAgB,eACjBG,EAAO,aAAgBH,EAAgB,cAEtCA,EAAgB,iBACjBG,EAAO,eAAkBH,EAAgB,gBAExCA,EAAgB,iBACjBG,EAAO,eAAkBH,EAAgB,gBAGtCG,CACX,CAMO,SAASC,GAAoC,CAChD,MAAO,CACH,OAAQ,CAAA,EACR,UAAW,CAAA,EACX,iBAAkB,CAAA,EAClB,OAAQ,GACR,YAAa,EAAA,CAErB"}